
ASSERTIONS

The method of loop invariants is an extension of the method of
assertions. An assertion is a logical statement that should evaluate to
true. Assertions as first conceived were just a technique of thought,
but now languages or libraries have adopted the technique so that an
assertion is an actual piece of code that is evaluated, and if it
evaluates false, the assertion fails, and the code flow might be
terminated.

On type of assertion is an assertion made before a block of code which
summarizes that the code will assume as true, and if not true, the code
might not work. These are also called pre-conditions. For instance, a
precondition for finding the maximum of a set of integers would be that
the set must be non-empty. The code that asserts a non-empty set as a
pre-condition does not have to reason about why the set is non-empty.
The user of the code must reason out why the code will never be run on
an empty set. The code that asserts the pre-condition can assume it
true.

The assertions that are made at the end of a code block summarize what
work the code has done. The assertion will pertain to the new
information or organization achieved by the code block, on the
assumption of the pre-condition, and this assertion is called the
post-condition. The code has transformed a world given by the
pre-conditions into a world given by the post-conditions.

For instance, the code:

   int f( struct * pair ) { 
       if ( pair->a < pair->b ) { 
            t = pair->a ;
            pair->a = pair->b ; 
            pair->b = t ;
       }
       // ASSERT: pair->a >= pair->b
    }

has transformed the very weak pre-condition that pair is a struct
containing to integers a and b to the post-condition that a is the
larger of the two, and b the smaller (or they are the same value).

Consider placing the fraction a/b into lowest terms. The code looks as
follows

    // ASSERT: a, b are integers, b!=0
    
    { code block U }

    // ASSERT: 0 < b <= a, and s is the sign of (the original) a/b
    
    { code block V }

    // ASSERT: d is the gcd(a,b) (function gcd's post-condition)
    
    { code block W }

    // ASSERT: a/b is in lowest terms


"I'VE BEEN SPEAKING PROSE ALL MY LIFE WITHOUT KNOWING IT"

The method of assertions is implicit each time a programmer references a
pointer (or, for Java programers, a reference). A null pointer cannot be
dereferenced. It will cause the program to crash, or the Java system to
throw an exception. The programmer mentally must have, or should have,
an assertion of non-null before the use of the pointer.

Null pointer exceptions (segmentation faults in C) are very common
because of the failure to satisfy this pre-condition to pointer use.
That means there was a failure of the post-condition leading up to the
pointer use.

     W
     // assert pointer p non-null (even, p is a non-null object of 
     // type T)
     dereference of p

The assertion is the post-condition of W and the pre-condition to
pointer use.

In this situation the method of assertions reminds the programmer that
there should be a good and hopefully simple reason why the pointer is
non-null. It encourages the programmer to recognize the logic that
achieves the assertion, and even encourages that the program structure
lend itself to simplify the logic that leads towards the assertion.



LOOP INVARIANTS

Given a loop:

   while CONDITION:

       code block W

how are we to reason about the correctness? In fact, this code unwinds
into a repeated sequence of runnings of W,

    W (1) 
    W (2)
    W (3)
    ...
    
where I have used the special notation W  (i)to signify the i-th
time through the loop body W.

The method of loop invariants will summarize correctness by asserting
that the pre-condition of W (i+1) is satisfied by the
post-condition of W (i); and since  W (i) and
 W (i+1) are the same code, the pre- and post- conditions of W
are the same. Since it is a logical expression that does not change, it
is called invariant, hence the name "the loop invariant".

If a proper loop invariant can be found, and the block W is coded to
that loop invariant, correctness follows easily. One only reasons about
a single running of W. The invariant insures that one W runs into the
next with out logical flaw.

Because progress must be made through the loop, something must change by
the code block W, and if the loop invariant is to be at all helpful for
correctness, it must be that what the code block changes affects the
invariant, and might in its workings temporarily make the invariant
false. But the code in W is obliged to restore the invariant to truth
before the end of its run.

