

ASSERTIONS

An assertion is a logical statement that should evaluate to true. Assertions can 
be just a mind-game - at most a notation or comment in the code, or they can be actual
code checks. They have become so popular that now some languages have assert statements, 
which evaluate the assertion and if false the code flow is terminated or an exception thrown.

There are three types of assertions of particular interest: pre-conditions,
post-conditions, and loop invariants. 

A code block, say W, must assume various things are true in order that it
function properly. One can assert before the code block those truths as
a logical statement, and call it a pre-condition for the code. An assertion
does not make it so - it is an attempt to make clear what needs to be made
true before block W runs.

The block W accomplishes something - it sets the world into a new state, and
further code can rely on that state. One can make an assertion modeling that
state and place it at the end of block W, and this is called a post-condition.
Just as with a pre-condition, asserting a post-condition does not make it true,
the block W makes it true. In fact, the promise of W is that if the world is
such that the pre-condition is true before the block runs, then it will take action 
such that the post-condition will be true once the block has run.

For instance, the code:

   int f( struct * pair ) { 
       if ( pair->a < pair->b ) { 
            t = pair->a ;
            pair->a = pair->b ; 
            pair->b = t ;
       }
       // ASSERT: pair->a >= pair->b
    }

has transformed the very weak pre-condition that pair is a struct
containing to integers a and b to the post-condition that a is the
larger of the two, and b the smaller (or they are the same value).

Consider placing the fraction a/b into lowest terms. The code looks as
follows

    // ASSERT: a, b are integers, b!=0
    
    { code block U }

    // ASSERT: 0 < b <= a, and s is the sign of (the original) a/b
    
    { code block V }

    // ASSERT: d is the gcd(a,b) (function gcd's post-condition)
    
    { code block W }

    // ASSERT: a/b is in lowest terms


"I'VE BEEN SPEAKING PROSE ALL MY LIFE WITHOUT KNOWING IT"

The method of assertions is implicit each time a programmer references a
pointer (or, for Java programers, a reference). A null pointer cannot be
dereferenced. It will cause the program to crash, or the Java system to
throw an exception. The programmer mentally must have, or should have,
an assertion of non-null before the use of the pointer.

Null pointer exceptions (segmentation faults in C) are very common
because of the failure to satisfy this pre-condition to pointer use.
That means there was a failure of the post-condition leading up to the
pointer use.

     W
     // assert pointer p non-null (even, p is a non-null object of 
     // type T)
     dereference of p

The assertion is the post-condition of W and the pre-condition to
pointer use.

In this situation the method of assertions reminds the programmer that
there should be a good and hopefully simple reason why the pointer is
non-null. It encourages the programmer to recognize the logic that
achieves the assertion, and even encourages that the program structure
lend itself to simplify the logic that leads towards the assertion.



LOOP INVARIANTS

Given a loop:

   while CONDITION:

       code block W

how are we to reason about the correctness? In fact, this code unwinds
into a repeated sequence of runnings of W,

    W (1) 
    W (2)
    W (3)
    ...
    
where I have used the special notation W  (i)to signify the i-th
time through the loop body W.

The method of loop invariants will summarize correctness by asserting
that the pre-condition of W (i+1) is satisfied by the
post-condition of W (i); and since  W (i) and
 W (i+1) are the same code, the pre- and post- conditions of W
are the same. Since it is a logical expression that does not change, it
is called invariant, hence the name "the loop invariant".

If a proper loop invariant can be found, and the block W is coded to
that loop invariant, correctness follows easily. One only reasons about
a single running of W. The invariant insures that one W runs into the
next with out logical flaw.

Because progress must be made through the loop, something must change by
the code block W, and if the loop invariant is to be at all helpful for
correctness, it must be that what the code block changes affects the
invariant, and might in its workings temporarily make the invariant
false. But the code in W is obliged to restore the invariant to truth
before the end of its run.

-burt rosenberg, Creative Commons share and share alike 2014
